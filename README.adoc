// = Kokkidio Readme
// :author: Lennart Steffen
// :email: Lennart.Steffen@wahyd.tu-berlin.de
:source-highlighter: highlight.js
:toc:
:toc-placement!:

:Eigen: https://eigen.tuxfamily.org/[Eigen]
:Kokkos: https://kokkos.org/[Kokkos]
:GPLv3: https://www.gnu.org/licenses/gpl-3.0.en.html[GPLv3]
:wahyd: https://www.wahyd.tu-berlin.de/

:mapview: link:./include/Kokkidio/MapView.hpp[MapView]
:dualmapview: link:./include/Kokkidio/DualMapView.hpp[DualMapView]
:parallelrange: link:./include/Kokkidio/ParallelRange.hpp[ParallelRange]


image::./media/Kokkidio_Logo.svg[]

_Kokkidio_ is a header-only template library 
designed to provide interoperability between the linear algebra library {Eigen} 
and the performance portability framework {Kokkos}. 
Its aim is to allow the easy-to-read, succinct source code of {Eigen} 
to be compiled to fast machine code on all the platforms supported by {Kokkos}.  

toc::[]


== Overview

_Kokkidio_ consists of three interlocking elements:

* The <<_data_structures, data structures>> `MapView` and `DualMapView`, 
which combine an `Eigen::Map` and a `Kokkos::View`,
* an iteration range class (`ParallelRange`), 
which allows threads to efficiently access their assigned elements, and
* parallel dispatch functions (`parallel_for` and `parallel_reduce`) 
compatible with functors taking `ParallelRange`.


== Data structures

=== `MapView`

The core of the `MapView` class (see link:./include/Kokkidio/MapView.hpp[file])
are the two member functions `map()` and `view()`,
which return an `Eigen::Map`, and a `Kokkos::View` respectively, 
and thus allow it to be used in either library's functions.

`MapView` takes two template parameters:

. `EigenType`: The `Eigen` class to be used as the map type, 
e.g. `Eigen::MatrixXd` or `Eigen::Array3i`. 
The return type of `map()` behaves the same way as this type. 
Only dense types are currently supported. 
. A `Target` enumeration value, which can be either `host` or `device`. 
This parameter is optional. 
Its default value matches `Kokkos::DefaultExecutionSpace`.

`MapView` can be instantiated either using an existing `Eigen` object, 
or using the same size parameters as you would for the `Eigen` type. 
Here's what happens when you create a `MapView`:

. With an existing `Eigen` object: 

.. Instantiation on `Target::host`:
No allocation is performed. 
An unmanaged `Kokkos::View` is created, 
using the existing object's data pointer and sizes.

.. Instantiation on `Target::device`:
the `Eigen` object's sizes are used to create a matching managed `Kokkos::View` 
on the device.

. With size parameters: 
A managed `Kokkos::View` is created using these sizes on `Target`.
The same size parameters are allowed as for the respective `Eigen` type.
This means, creating vector types (1D) requires only a single size parameter,
and fixed size types can be created without them.

In all of the above cases, the data pointers of `view()` and `map()` 
contain the same address. 
Furthermore, when instantiating a `MapView` with 
a non-const, owning `Eigen` object (i.e. not itself an `Eigen::Map`),
a non-owning pointer to the object is stored 
to allow resizing both the `Kokkos::View` and the `Eigen` object 
via `MapView::resize()`.

==== Examples

The examples below are taken from
link:./src/examples/MapView.cpp[examples/MapView.cpp].

.Expand examples for instantiating a MapView
[%collapsible]
====
[,cpp]
----
using namespace Kokkidio;
int nRows {10}, nCols {20};

/* existing Eigen object */
Eigen::ArrayXXd eigenArray {nRows, nCols};

/* Create MapView using a constructor or factory function.
 * Deduces Eigen type, and uses default target */
MapView mv1 {eigenArray};
auto mv2 = mapView(eigenArray);

/* Create MapView using factory function for specific target,
 * while deducing Eigen type */
auto mv3 = mapView<Target::host>(eigenArray);

/* Create MapView using size parameters. 
 * ArrayXXd is dynamically sized in both dimensions, 
 * so two parameters are required */
MapView<Eigen::ArrayXXd> mv4 {nRows, nCols};

/* ArrayXd is a column vector, so only rows are required */
MapView<Eigen::ArrayXd> mv5 {nRows};

/* Array3d is a fixed size type, so no parameters are required */
MapView<Eigen::Array3d> mv6;
----
====

==== Synopsis

.Expand synopsis of DualMapView
[%collapsible]
====
[,cpp]
----

template<typename _EigenType, Target targetArg = DefaultTarget>
class MapView {
public:
	static constexpr Target target { ExecutionTarget<targetArg> };
	using EigenType_host = _EigenType;
	/* EigenType_host and EigenType_target may differ in const-ness */
	using EigenType_target = std::conditional_t<target == Target::host,
		EigenType_host,
		std::remove_const_t<EigenType_host>
	>;

	using ThisType = MapView<EigenType_target, target>;

	using Scalar     = typename EigenType_target::Scalar;
	using MapType    = Eigen::Map<EigenType_host>;
	/* only types with a continuous memory layout are currently supported */
	static_assert( is_contiguous<EigenType_target>() );

	/* Translations of "target" into Kokkos spaces */
	using MemorySpace    = Kokkidio::MemorySpace   <target>;
	using ExecutionSpace = Kokkidio::ExecutionSpace<target>;
	/* The Kokkos::View data type is either fully dynamic or fully fixed-size,
	 * i.e. Scalar** or Scalar[nRows][nCols],
	 * and always uses LayoutLeft */
	using ViewType   = Kokkos::View<..., Kokkos::LayoutLeft, MemorySpace>;
	using HostMirror = typename ViewType::HostMirror;

protected:
	ViewType m_view;
	observer_ptr<EigenType_host> m_obj {nullptr};

public:

	/* constructors */
	MapView(); // default (no allocation) or fixed size types
	MapView(Index size); // 1D types
	MapView(Index rows, Index cols); // 2D types
	MapView( _EigenType& hostObj ); // existing Eigen objects

	/* "resize" and constructors can only be called from host */
	void resize(Index rows, Index cols);

	/* get some info about type and status */
	KOKKOS_FUNCTION constexpr bool isManaged() const;
	KOKKOS_FUNCTION bool isAlloc() const;

	/* data pointer */
	KOKKOS_FUNCTION Scalar* data();
	KOKKOS_FUNCTION const Scalar* data() const;

	/* get Eigen::Map */
	KOKKOS_FUNCTION MapType map() const;

	/* and Kokkos::View */
	KOKKOS_FUNCTION ViewType view() const;

	/* sizes */
	KOKKOS_FUNCTION Index rows() const;
	KOKKOS_FUNCTION Index cols() const;
	KOKKOS_FUNCTION Index size() const;
};

/* detection */
template<typename T>
inline constexpr bool is_MapView_v = ...;


/* factory functions */

/* specify target, deduce EigenType */
template<Target target = DefaultTarget, typename EigenType>
MapView<EigenType, target> mapView( EigenType& eigenObj );

/* specify EigenType, optionally specify target, fixed size */
template<typename EigenType, Target target = DefaultTarget>
MapView<EigenType, target> mapView();

/* specify EigenType, optionally specify target, 1D */
template<typename EigenType, Target target = DefaultTarget>
MapView<EigenType, target> mapView(Index vectorSize);

/* specify EigenType, optionally specify target, 2D */
template<typename EigenType, Target target = DefaultTarget>
MapView<EigenType, target> mapView(Index rows, Index cols);
----
====

=== `DualMapView`

`DualMapView` (see link:./include/Kokkidio/DualMapView.hpp[file])
is designed to facilitate easy data exchange between `host` 
and the compute `Target`. 
To this end, it provides the member functions
`copyToTarget()` 
and 
`copyToHost()`.


It takes the same template parameters as <<_mapview,`MapView`>>, 
i.e. an `Eigen` type, and a `Target` value.
While a `MapView` only exists on _either_ `host` or `device`, 
`DualMapView` always consists of _two_ ``MapView``s, 
of which one is located on `host`, 
and the other on the specified `Target`. 
If the `Target` is also `host`, then the two views are identical,
and `copyTo...()` operations are correspondingly skipped.

To access the ``MapView``s, it provides the member functions
`get_host()`
and
`get_target()`,
as well as shortcuts to their ``map()``/``view()`` member functions 
in the form of
``map_host()``/``map_target()`` and ``view_host()``/``view_target()``.

Similar to <<_mapview,`MapView`>>, it also allows to `resize()` its data,
and does so on both `host` and the specified `Target`.


== Examples

The `MapView` and `DualMapView` classes can be instantiated in a similar fashion to `Eigen` classes, 
with similar behaviour:

```c++
using namespace Kokkidio;
MapView<Eigen::MatrixXd>
	a, // default construction, no allocation
	b (2, 3); // constructs 
```
and [`DualMapView`] are designed to function  
Here's an example using a `DualMapView`:

```c++
/* "Target" is an enum containing "host" and "device".
 * Generally, you can just set it to "DefaultTarget",
 * which queries Kokkos' default execution space. */
constexpr target {DefaultTarget};
using MatrixView = DualMapView<Eigen::MatrixXd, target>;
int nRows {4}, nCols {1000};

/* The DualMapView constructors which take sizes allocate memory 
 * on both host and target: */
MatrixView mat (nRows, nCols);

/* The DualMapView constructors which take Eigen objects only allocate
 * memory on the target, or none at all, if target==host: */
Eigen::MatrixXd existingMat (nRows, nCols);
MatrixView mat2 {existingMat};

/* You can use Kokkos routines via the view_[host|target]() member functions, 
 * e.g. for setting all elements to 123: */
Kokkos::deep_copy(mat.view_host(), 123);

/* or you can use Eigen routines via map_[host|target](): */
mat.map_host().setRandom();

/* Copy data to the target space (does nothing if target==host): */
mat.copyToTarget();

/* To operate on it, we create a functor, which is then passed to 
 * a parallel dispatch function. Our functor here gets the sum of our data: */
auto func = KOKKOS_LAMBDA(ParallelRange<target> rng, double& sum){
	/* pass an Eigen(Dual)View or Eigen object to a ParallelRange
	 * to get the elements associated with a thread (Eigen::Block) */
	sum += rng(mat);
}

double result {0};
/* parallel_[for|reduce] in the Kokkidio namespace allow passing functions 
 * which take a ParallelRange, but otherwise they work exactly like
 * Kokkos::parallel_[for|reduce]: */
parallel_reduce<DefaultTarget>( nCols, func, redux::sum(result) );
```

== Licence

_Kokkidio_ is maintained by the
Chair of Water Resources Management and Modelling of Hydrosystems of the
Technische Universität Berlin,
or *wahyd* for short ({wahyd}[Link]).
It is distributed under a {gplv3} (link:./LICENCE[Licence text]).
Licence types for the libraries used in _Kokkidio_
are listed in the link:./LICENCE.README[LICENCE.README] file.

== Name and Logo

The name _Kokkidio_ is based on the assumptions that 

. {Kokkos} refers to the Greek *Κόκκος* (engl.: *grain*, though possibly a play on *kernel*), and that 
. {Eigen} refers to eigenvalues and eigenvectors.

The latter are _ιδιοτιμή_ (idiotimí) and _ιδιοδιάνυσμα_ (idiodiánysma) in Greek, 
from which the prefix _ιδιο_ (idio) was taken
(engl.: _same_, though it could also be from _ίδιος_ = own, or self, 
which is the meaning of _eigen_ in German). 
_κοκκίδιο_ (kokkídio) could be seen as a https://en.wikipedia.org/wiki/Portmanteau[portmanteau] of _Kokkos_ and _idio_, 
but is in fact the Greek word for _granule_, so not far off _Kokkos_ itself.

The logo is a stretched/sheared map of a recolouration of the https://kokkos.org/img/kokkos-logo.png[Kokkos logo], 
with the eigenvectors of that mapping drawn as arrows.


